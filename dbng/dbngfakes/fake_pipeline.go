// This file was generated by counterfeiter
package dbngfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db/lock"
	"github.com/concourse/atc/dbng"
)

type FakePipeline struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	SaveJobStub        func(job atc.JobConfig) error
	saveJobMutex       sync.RWMutex
	saveJobArgsForCall []struct {
		job atc.JobConfig
	}
	saveJobReturns struct {
		result1 error
	}
	CreateJobBuildStub        func(jobName string) (dbng.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		jobName string
	}
	createJobBuildReturns struct {
		result1 dbng.Build
		result2 error
	}
	CreateResourceStub        func(name string, config atc.ResourceConfig) (*dbng.Resource, error)
	createResourceMutex       sync.RWMutex
	createResourceArgsForCall []struct {
		name   string
		config atc.ResourceConfig
	}
	createResourceReturns struct {
		result1 *dbng.Resource
		result2 error
	}
	AcquireResourceCheckingLockStub        func(logger lager.Logger, resource *dbng.Resource, resourceTypes atc.ResourceTypes, length time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockMutex       sync.RWMutex
	acquireResourceCheckingLockArgsForCall []struct {
		logger        lager.Logger
		resource      *dbng.Resource
		resourceTypes atc.ResourceTypes
		length        time.Duration
		immediate     bool
	}
	acquireResourceCheckingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	} else {
		return fake.iDReturns.result1
	}
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) SaveJob(job atc.JobConfig) error {
	fake.saveJobMutex.Lock()
	fake.saveJobArgsForCall = append(fake.saveJobArgsForCall, struct {
		job atc.JobConfig
	}{job})
	fake.recordInvocation("SaveJob", []interface{}{job})
	fake.saveJobMutex.Unlock()
	if fake.SaveJobStub != nil {
		return fake.SaveJobStub(job)
	} else {
		return fake.saveJobReturns.result1
	}
}

func (fake *FakePipeline) SaveJobCallCount() int {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return len(fake.saveJobArgsForCall)
}

func (fake *FakePipeline) SaveJobArgsForCall(i int) atc.JobConfig {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return fake.saveJobArgsForCall[i].job
}

func (fake *FakePipeline) SaveJobReturns(result1 error) {
	fake.SaveJobStub = nil
	fake.saveJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) CreateJobBuild(jobName string) (dbng.Build, error) {
	fake.createJobBuildMutex.Lock()
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("CreateJobBuild", []interface{}{jobName})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(jobName)
	} else {
		return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
	}
}

func (fake *FakePipeline) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakePipeline) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].jobName
}

func (fake *FakePipeline) CreateJobBuildReturns(result1 dbng.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateResource(name string, config atc.ResourceConfig) (*dbng.Resource, error) {
	fake.createResourceMutex.Lock()
	fake.createResourceArgsForCall = append(fake.createResourceArgsForCall, struct {
		name   string
		config atc.ResourceConfig
	}{name, config})
	fake.recordInvocation("CreateResource", []interface{}{name, config})
	fake.createResourceMutex.Unlock()
	if fake.CreateResourceStub != nil {
		return fake.CreateResourceStub(name, config)
	} else {
		return fake.createResourceReturns.result1, fake.createResourceReturns.result2
	}
}

func (fake *FakePipeline) CreateResourceCallCount() int {
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	return len(fake.createResourceArgsForCall)
}

func (fake *FakePipeline) CreateResourceArgsForCall(i int) (string, atc.ResourceConfig) {
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	return fake.createResourceArgsForCall[i].name, fake.createResourceArgsForCall[i].config
}

func (fake *FakePipeline) CreateResourceReturns(result1 *dbng.Resource, result2 error) {
	fake.CreateResourceStub = nil
	fake.createResourceReturns = struct {
		result1 *dbng.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) AcquireResourceCheckingLock(logger lager.Logger, resource *dbng.Resource, resourceTypes atc.ResourceTypes, length time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	fake.acquireResourceCheckingLockArgsForCall = append(fake.acquireResourceCheckingLockArgsForCall, struct {
		logger        lager.Logger
		resource      *dbng.Resource
		resourceTypes atc.ResourceTypes
		length        time.Duration
		immediate     bool
	}{logger, resource, resourceTypes, length, immediate})
	fake.recordInvocation("AcquireResourceCheckingLock", []interface{}{logger, resource, resourceTypes, length, immediate})
	fake.acquireResourceCheckingLockMutex.Unlock()
	if fake.AcquireResourceCheckingLockStub != nil {
		return fake.AcquireResourceCheckingLockStub(logger, resource, resourceTypes, length, immediate)
	} else {
		return fake.acquireResourceCheckingLockReturns.result1, fake.acquireResourceCheckingLockReturns.result2, fake.acquireResourceCheckingLockReturns.result3
	}
}

func (fake *FakePipeline) AcquireResourceCheckingLockCallCount() int {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockArgsForCall)
}

func (fake *FakePipeline) AcquireResourceCheckingLockArgsForCall(i int) (lager.Logger, *dbng.Resource, atc.ResourceTypes, time.Duration, bool) {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return fake.acquireResourceCheckingLockArgsForCall[i].logger, fake.acquireResourceCheckingLockArgsForCall[i].resource, fake.acquireResourceCheckingLockArgsForCall[i].resourceTypes, fake.acquireResourceCheckingLockArgsForCall[i].length, fake.acquireResourceCheckingLockArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceCheckingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockStub = nil
	fake.acquireResourceCheckingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	} else {
		return fake.destroyReturns.result1
	}
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.createResourceMutex.RLock()
	defer fake.createResourceMutex.RUnlock()
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbng.Pipeline = new(FakePipeline)
